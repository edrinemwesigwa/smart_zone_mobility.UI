'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PptxGenJS = require('pptxgenjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PptxGenJS__default = /*#__PURE__*/_interopDefaultLegacy(PptxGenJS);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// styleTransform.ts
function colorToHex(color) {
    if (!color || color === "transparent" || color === "inherit")
        return "";
    if (color.startsWith("#"))
        return color.replace("#", "").toUpperCase();
    if (color.startsWith("rgb")) {
        var rgba = color.match(/(\d+(\.\d+)?)/g);
        if (rgba && rgba.length >= 3) {
            if (rgba.length > 3 && parseFloat(rgba[3]) === 0)
                return "";
            var r = parseInt(rgba[0], 10).toString(16).padStart(2, "0");
            var g = parseInt(rgba[1], 10).toString(16).padStart(2, "0");
            var b = parseInt(rgba[2], 10).toString(16).padStart(2, "0");
            return (r + g + b).toUpperCase();
        }
    }
    return "000000";
}
/**
 * 计算最终的透明度 (0-100, 0是不透明)
 * 结合了 rgba 的 alpha 通道 和 css 的 opacity 属性
 */
function getMixedTransparency(colorStr, cssOpacity) {
    var alpha = 1;
    // 1. 解析 CSS Opacity (0 ~ 1)
    var elementOpacity = parseFloat(cssOpacity);
    if (!isNaN(elementOpacity)) {
        alpha *= elementOpacity;
    }
    // 2. 解析 RGBA Alpha
    if (colorStr && colorStr.startsWith("rgba")) {
        var rgba = colorStr.match(/(\d+(\.\d+)?)/g);
        if (rgba && rgba.length >= 4) {
            var colorAlpha = parseFloat(rgba[3]);
            alpha *= colorAlpha;
        }
    }
    // 如果完全不透明 (alpha=1)，返回 undefined 让 pptxgenjs 使用默认
    if (alpha >= 1)
        return undefined;
    // PPTX Transparency is 0 (opaque) to 100 (fully transparent)
    return Math.round((1 - alpha) * 100);
}
/**
 * 将元素的 CSS 计算样式转换为 PPT 坐标/样式
 * 注意：坐标和尺寸 x/y/w/h 使用 globalScale/pageTransformScale 缩放；
 * 字体/行高/边框等“点数”属性仅进行单位转换 px->pt，不乘 globalScale，避免双重缩放。
 */
function getComputedElementStyle(element, pageRect, globalScale, pageTransformScale) {
    var _a, _b;
    var style = window.getComputedStyle(element);
    var rect = element.getBoundingClientRect();
    // 坐标/尺寸：px -> ppt英寸(基于 globalScale)，pptxgenjs 用英寸单位；这里维持你现有的比例策略：
    // 现有项目通常将 px*globalScale 再映射到 ppt 布局宽度（已在上层计算 globalScale）。保持不变。
    var x = ((rect.left - pageRect.left) / pageTransformScale) * globalScale;
    var y = ((rect.top - pageRect.top) / pageTransformScale) * globalScale;
    var w = (rect.width / pageTransformScale) * globalScale;
    var h = (rect.height / pageTransformScale) * globalScale;
    // 字体大小：px -> pt（仅单位转换，1px ≈ 0.75pt）
    var pxFontSize = parseFloat(style.fontSize) || 14;
    var fontSize = pxFontSize * globalScale * 72;
    // 字体
    var fontFace = (_a = style.fontFamily) === null || _a === void 0 ? void 0 : _a.split(",")[0].replace(/['"]/g, "");
    // 颜色
    var color = colorToHex(style.color);
    // 对齐
    var align = (function () {
        switch (style.textAlign) {
            case "left":
            case "start":
                return "left";
            case "center":
                return "center";
            case "right":
            case "end":
                return "right";
            case "justify":
                return "justify";
            default:
                return undefined;
        }
    })();
    var valign = (function () {
        switch (style.verticalAlign) {
            case "top":
                return "top";
            case "middle":
            case "center":
                return "middle";
            case "bottom":
                return "bottom";
            // [修改] CSS 默认是基线对齐或顶端对齐，PPT 默认是居中。强制默认为 top 以对齐浏览器视觉
            default:
                return "top";
        }
    })();
    // 行高：CSS -> pt
    var lineSpacing;
    var lh = style.lineHeight;
    if (lh === "normal" || !lh) {
        lineSpacing = fontSize * 1.2; // 默认约为 1.2 倍字体大小
    }
    else if (/^\d+(\.\d+)?$/.test(lh)) {
        // 数字倍数
        lineSpacing = fontSize * parseFloat(lh);
    }
    else {
        // px 或其它单位，粗略按 px -> pt
        var pxLineHeight = parseFloat(lh);
        if (!isNaN(pxLineHeight)) {
            lineSpacing = pxLineHeight * 0.75;
        }
    }
    // 字间距（letter-spacing）px->pt
    var charSpacing;
    var ls = style.letterSpacing;
    if (ls && ls !== "normal") {
        var pxLs = parseFloat(ls);
        if (!isNaN(pxLs)) {
            charSpacing = pxLs * 0.75;
        }
    }
    // 解析旋转角度
    var rotate;
    if (style.transform && style.transform !== "none") {
        // transform: matrix(a, b, c, d, tx, ty)
        var values = (_b = style.transform.split("(")[1]) === null || _b === void 0 ? void 0 : _b.split(")")[0].split(",");
        if (values && values.length >= 4) {
            var a = parseFloat(values[0]);
            var b = parseFloat(values[1]);
            // 计算角度 (弧度转角度)
            var angle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
            if (angle !== 0)
                rotate = angle;
        }
    }
    // --- Opacity 解析 ---
    var cssOpacity = style.opacity || "1";
    var opacityVal = parseFloat(cssOpacity); // 0-1
    // 背景填充
    var bgColor = colorToHex(style.backgroundColor);
    var fill = bgColor && bgColor !== ""
        ? {
            color: bgColor,
            transparency: getMixedTransparency(style.backgroundColor, cssOpacity),
        }
        : undefined;
    // 边框（统一采用 px->pt，不叠加 globalScale，避免双重缩放）
    var border;
    var borderWidth = parseFloat(style.borderWidth);
    if (borderWidth > 0 && style.borderStyle !== "none" && style.borderColor) {
        border = {
            pt: borderWidth * 0.75,
            color: colorToHex(style.borderColor),
            type: style.borderStyle === "dashed" ? "dash" : "solid",
        };
    }
    // --- 圆角 (Border Radius) ---
    var borderRadiusRaw = style.borderRadius || "0px";
    var radiusPx = parseFloat(borderRadiusRaw);
    var minSide = Math.min(rect.width, rect.height);
    // 默认形状
    var shapeType = "rect";
    var rectRadius = undefined;
    if (radiusPx > 0 && minSide > 0) {
        // 1. 判断是否为“完全圆形”
        var isSquare = Math.abs(rect.width - rect.height) < 1.5;
        var isFullRound = radiusPx >= minSide / 2 - 0.5; // 允许0.5px误差
        if (isSquare && isFullRound) {
            shapeType = "ellipse";
            rectRadius = undefined; // 椭圆不需要圆角参数
        }
        else {
            shapeType = "roundRect";
            // 精确计算比例：CSS像素 / 元素短边
            var ratio = radiusPx / 130;
            // ratio = 0.1;
            if (ratio > 0.5)
                ratio = 0.5;
            rectRadius = ratio;
            // console.log("Computed borderRadius:", borderRadiusRaw, "->", rectRadius);
        }
    }
    // 文本样式
    var bold = parseInt(style.fontWeight || "400", 10) >= 600 || style.fontWeight === "bold";
    var italic = style.fontStyle === "italic";
    var underline = style.textDecoration.includes("underline");
    var strike = style.textDecoration.includes("line-through");
    // 内边距（用于表格单元格等）
    var padding;
    var pt = function (v) { return (parseFloat(v || "0") || 0) * 0.75; };
    var ptTop = pt(style.paddingTop);
    var ptRight = pt(style.paddingRight);
    var ptBottom = pt(style.paddingBottom);
    var ptLeft = pt(style.paddingLeft);
    if (ptTop || ptRight || ptBottom || ptLeft) {
        padding = [ptTop, ptRight, ptBottom, ptLeft];
    }
    return {
        x: x,
        y: y,
        w: w,
        h: h,
        fontSize: fontSize,
        fontFace: fontFace,
        color: color,
        align: align,
        valign: valign,
        lineSpacing: lineSpacing,
        charSpacing: charSpacing,
        fill: fill,
        border: border,
        bold: bold,
        italic: italic,
        underline: underline,
        strike: strike,
        padding: padding,
        shapeType: shapeType,
        rectRadius: rectRadius,
        opacity: opacityVal,
        rotate: rotate,
    };
}

// animationTransform.ts
// 映射常见 CSS 动画名到 pptxgenjs 动画类型
var ANIMATION_MAP = {
    fadeIn: "fadeIn",
    fadeInUp: "flyInBottom",
    fadeInDown: "flyInTop",
    fadeInLeft: "flyInLeft",
    fadeInRight: "flyInRight",
    zoomIn: "zoomIn",
    bounceIn: "bounce",
    // 常见 slide/animate.css 命名
    slideInUp: "flyInBottom",
    slideInDown: "flyInTop",
    slideInLeft: "flyInLeft",
    slideInRight: "flyInRight",
};
/**
 * 获取元素动画配置
 * 优先 data-pptx-animation，其次 CSS animationName 映射
 */
function getElementAnimation(element) {
    var _a, _b;
    var style = window.getComputedStyle(element);
    // 显式 data 属性优先
    var dataAnim = element.getAttribute("data-pptx-animation");
    if (dataAnim) {
        var duration = parseInt(element.getAttribute("data-pptx-duration") || "1000", 10) / 1000;
        var delay = parseInt(element.getAttribute("data-pptx-delay") || "0", 10) / 1000;
        return { type: dataAnim, duration: duration, delay: delay };
    }
    // CSS 动画解析（取第一个）
    var animName = style.animationName;
    if (animName && animName !== "none") {
        var primaryAnim_1 = animName.split(",")[0].trim();
        var pptAnimType = ANIMATION_MAP[primaryAnim_1];
        // 模糊匹配，如 animate__fadeIn
        if (!pptAnimType) {
            var key = Object.keys(ANIMATION_MAP).find(function (k) { return primaryAnim_1.toLowerCase().includes(k.toLowerCase()); });
            if (key)
                pptAnimType = ANIMATION_MAP[key];
        }
        if (pptAnimType) {
            var durationStr = (_a = style.animationDuration.split(",")[0]) !== null && _a !== void 0 ? _a : "1s";
            var delayStr = (_b = style.animationDelay.split(",")[0]) !== null && _b !== void 0 ? _b : "0s";
            var parseTime = function (t) {
                var val = parseFloat(t);
                return t.includes("ms") ? val / 1000 : val;
            };
            return {
                type: pptAnimType,
                duration: parseTime(durationStr) || 1,
                delay: parseTime(delayStr) || 0,
            };
        }
    }
    return undefined;
}

var PPT_LAYOUT = {
    width: 10,
    height: 5.625,
};
/**
 * 解析富文本 - 独立坐标模式
 * 不再聚合文本，而是计算每个 TextNode 的真实屏幕位置
 */
function parseRichText(rootElement, pageRect, // 需要传入页面容器的 rect 用于计算相对坐标
globalScale, pageTransformScale) {
    var shapes = [];
    var consumedElements = new Set();
    function traverse(node, parentStyle) {
        var _a;
        // 1. 处理文本节点
        if (node.nodeType === Node.TEXT_NODE) {
            var textContent = node.textContent || "";
            if (!textContent.trim())
                return;
            var range = document.createRange();
            range.selectNode(node);
            var rect = range.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0)
                return;
            // --- 坐标计算 (逻辑同 getComputedElementStyle) ---
            // 计算相对于 PPT 页面的坐标
            var x = ((rect.left - pageRect.left) / pageTransformScale) * globalScale;
            var y = ((rect.top - pageRect.top) / pageTransformScale) * globalScale;
            // 宽度缓冲：为了防止 PPT 换行，稍微给宽一点点 (例如 + 2px 对应的 ppt单位)
            // 也可以选择不加缓冲，但 PPT 渲染引擎通常比浏览器占宽
            var w = (rect.width / pageTransformScale) * globalScale + 0.05;
            var h = (rect.height / pageTransformScale) * globalScale;
            // --- 样式计算 ---
            var pxSize = parseFloat(parentStyle.fontSize || "14");
            var ptSize = pxSize * globalScale * 72;
            var bgColor = colorToHex(parentStyle.backgroundColor);
            // 将该文本节点作为一个独立的文本框对象存入
            shapes.push({
                text: textContent,
                options: {
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    fontSize: ptSize,
                    color: colorToHex(parentStyle.color),
                    fontFace: (_a = parentStyle.fontFamily) === null || _a === void 0 ? void 0 : _a.split(",")[0].replace(/['"]/g, ""),
                    bold: parseInt(parentStyle.fontWeight) >= 600 || parentStyle.fontWeight === "bold",
                    italic: parentStyle.fontStyle === "italic",
                    underline: parentStyle.textDecoration.includes("underline") ? { style: "sng" } : undefined,
                    strike: parentStyle.textDecoration.includes("line-through"),
                    highlight: bgColor ? bgColor : undefined,
                    subscript: parentStyle.verticalAlign === "sub",
                    superscript: parentStyle.verticalAlign === "super",
                    align: "left", // 强制左对齐，因为 x 坐标已经是文本的起点了
                    valign: "top", // 强制顶对齐
                    autoFit: false,
                    wrap: true, // 允许换行，防止溢出，但通常 rect 已经是一行的宽度了
                    inset: 0, // 去除内边距，保证位置精准
                },
            });
        }
        // 2. 处理元素节点
        else if (node.nodeType === Node.ELEMENT_NODE) {
            var el = node;
            var stopTags = ["TABLE", "IMG", "CANVAS", "SVG", "VIDEO", "IFRAME"];
            if (stopTags.includes(el.tagName)) {
                // 直接 return，不加入 consumedElements。
                // 这样 processElement 的递归循环 (Array.from(element.children))
                // 依然会遍历到这个节点，并调用专门的 addTable/addImage 逻辑。
                return;
            }
            var style_1 = window.getComputedStyle(el);
            if (el.tagName === "BR") {
                // BR 标签在独立坐标模式下通常不需要处理，
                // 因为下一个文本节点的 Range rect 会自动出现在下一行
                consumedElements.add(el);
                return;
            }
            // 布局边界检查 (同上一次修改)
            var isBlock = style_1.display === "block" || style_1.display === "flex" || style_1.display === "grid" || style_1.display === "inline-block" || style_1.position === "absolute" || style_1.position === "fixed";
            var isStyleTag = ["SPAN", "B", "STRONG", "I", "EM", "U", "FONT", "SUB", "SUP", "A", "SMALL", "BIG"].includes(el.tagName);
            // 如果是块级元素且不是样式标签，跳过，留给 processElement
            if (isBlock && !isStyleTag) {
                return;
            }
            if (style_1.display === "none" || style_1.visibility === "hidden" || style_1.opacity === "0") {
                consumedElements.add(el);
                return;
            }
            consumedElements.add(el);
            el.childNodes.forEach(function (child) { return traverse(child, style_1); });
        }
    }
    var rootStyle = window.getComputedStyle(rootElement);
    rootElement.childNodes.forEach(function (child) { return traverse(child, rootStyle); });
    return { shapes: shapes, consumedElements: consumedElements };
}
/**
 * 处理单个元素
 */
function processElement(element, slide, pageRect, globalScale, pageTransformScale) {
    if (element.getAttribute("hidden") !== null)
        return;
    var style = window.getComputedStyle(element);
    if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0")
        return;
    var pptStyle = getComputedElementStyle(element, pageRect, globalScale, pageTransformScale);
    var animation = getElementAnimation(element);
    // ============================================================
    // --- 0. 优先处理原生图表 (Native Chart) ---
    // 检查是否存在 data-pptx-chart-config 属性
    // ============================================================
    var chartConfigStr = element.getAttribute("data-pptx-chart-config");
    if (chartConfigStr) {
        try {
            // 解析配置
            var chartConfig = JSON.parse(chartConfigStr);
            // 合并样式：DOM 的位置 + JSON 中的配置
            // JSON 中的 options 优先级更高，允许用户覆盖自动计算的 x,y,w,h
            var finalOptions = __assign({ x: pptStyle.x, y: pptStyle.y, w: pptStyle.w, h: pptStyle.h }, chartConfig.options);
            // 添加原生图表
            slide.addChart(chartConfig.type, chartConfig.data, finalOptions);
            // 如果成功处理了图表，直接返回，不再作为图片或文本处理
            return;
        }
        catch (e) {
            console.warn("解析图表配置失败，将回退到截图模式:", e);
            // 解析失败不 return，继续往下走，尝试作为 Canvas/Image 截图处理
        }
    }
    // --- 1. 处理图片 ---
    if (element.tagName === "IMG") {
        var imgEl = element;
        if (imgEl.src) {
            slide.addImage(__assign({ path: imgEl.src, x: pptStyle.x, y: pptStyle.y, w: pptStyle.w, h: pptStyle.h, sizing: { type: "contain", w: pptStyle.w, h: pptStyle.h } }, (animation ? { animate: { type: animation.type, duration: animation.duration } } : {})));
        }
        return;
    }
    // --- 2. 处理 Canvas (图表的回退方案) ---
    if (element.tagName === "CANVAS") {
        try {
            var canvas = element;
            // 增加判断：如果是空 canvas 或者 tainted canvas 可能会报错
            var imgData = canvas.toDataURL("image/png");
            slide.addImage(__assign({ data: imgData, x: pptStyle.x, y: pptStyle.y, w: pptStyle.w, h: pptStyle.h }, (animation ? { animate: { type: animation.type, duration: animation.duration } } : {})));
        }
        catch (e) {
            console.warn("Canvas export failed", e);
        }
        return;
    }
    // --- 3. 处理表格 ---
    if (element.tagName === "TABLE") {
        // ... (保持原有的 Table 处理逻辑不变) ...
        var tableElement = element;
        var rows = Array.from(tableElement.querySelectorAll("tr"));
        if (rows.length === 0)
            return;
        var colWidthsPx_1 = [];
        var maxCols_1 = 0;
        rows.forEach(function (row) {
            var currentCols = 0;
            Array.from(row.children).forEach(function (cell) {
                currentCols += parseInt(cell.getAttribute("colspan") || "1");
            });
            if (currentCols > maxCols_1)
                maxCols_1 = currentCols;
        });
        for (var i = 0; i < maxCols_1; i++)
            colWidthsPx_1.push(0);
        rows.forEach(function (row) {
            var currentColIdx = 0;
            Array.from(row.children).forEach(function (cell) {
                var cellRect = cell.getBoundingClientRect();
                var colSpan = parseInt(cell.getAttribute("colspan") || "1");
                var cellPxWidth = cellRect.width;
                var avgColWidth = cellPxWidth / colSpan;
                for (var i = 0; i < colSpan; i++) {
                    if (colWidthsPx_1[currentColIdx + i] === 0 || avgColWidth > colWidthsPx_1[currentColIdx + i]) {
                        colWidthsPx_1[currentColIdx + i] = avgColWidth;
                    }
                }
                currentColIdx += colSpan;
            });
        });
        var colW = colWidthsPx_1.map(function (px) { return (px / pageTransformScale) * globalScale; });
        var totalPptColWidth = colW.reduce(function (sum, val) { return sum + val; }, 0);
        if (totalPptColWidth > 0 && Math.abs(totalPptColWidth - pptStyle.w) > 0.01) {
            var scaleFactor = pptStyle.w / totalPptColWidth;
            for (var i = 0; i < colW.length; i++)
                colW[i] *= scaleFactor;
        }
        else if (colW.length === 0 && rows.length > 0) {
            colW.push.apply(colW, Array(maxCols_1 > 0 ? maxCols_1 : 1).fill(pptStyle.w / (maxCols_1 > 0 ? maxCols_1 : 1)));
        }
        var rowH_1 = [];
        rows.forEach(function (row) {
            var rowRect = row.getBoundingClientRect();
            rowH_1.push((rowRect.height / pageTransformScale) * globalScale);
        });
        var tableData_1 = [];
        rows.forEach(function (row) {
            var rowData = [];
            var cells = Array.from(row.querySelectorAll("td, th"));
            cells.forEach(function (cell) {
                var cellStyle = getComputedElementStyle(cell, pageRect, globalScale, pageTransformScale);
                var cellTxt = cell.textContent || "";
                rowData.push({
                    text: cellTxt,
                    options: {
                        fill: cellStyle.fill,
                        color: cellStyle.color,
                        bold: cellStyle.bold,
                        italic: cellStyle.italic,
                        underline: cellStyle.underline,
                        strike: cellStyle.strike,
                        align: cellStyle.align,
                        valign: cellStyle.valign,
                        margin: cellStyle.padding,
                        border: cellStyle.border
                            ? {
                                pt: cellStyle.border.pt,
                                color: cellStyle.border.color,
                                type: cellStyle.border.type,
                            }
                            : undefined,
                        rowspan: parseInt(cell.getAttribute("rowspan") || "1"),
                        colspan: parseInt(cell.getAttribute("colspan") || "1"),
                        fontSize: cellStyle.fontSize,
                        fontFace: cellStyle.fontFace,
                        lineSpacing: cellStyle.lineSpacing,
                        charSpacing: cellStyle.charSpacing,
                        wrap: true,
                        autoFit: false,
                    },
                });
            });
            if (rowData.length)
                tableData_1.push(rowData);
        });
        if (tableData_1.length) {
            slide.addTable(tableData_1, {
                x: pptStyle.x,
                y: pptStyle.y,
                w: pptStyle.w,
                colW: colW.length > 0 ? colW : undefined,
                rowH: rowH_1.length > 0 ? rowH_1 : undefined,
                fill: pptStyle.fill,
                line: pptStyle.border,
            });
        }
        return;
    }
    // --- 4. 预先计算文本 (先不画，只计算) ---
    var _a = parseRichText(element, pageRect, globalScale, pageTransformScale), shapes = _a.shapes, consumedElements = _a.consumedElements;
    // --- 5. 普通容器 (背景/边框/动画) ---
    var hasBackground = pptStyle.fill && pptStyle.fill.color;
    var hasBorder = pptStyle.border;
    if (hasBackground || hasBorder || (shapes.length === 0 && !["SPAN", "B", "I", "U", "STRONG", "EM"].includes(element.tagName))) {
        slide.addShape(pptStyle.shapeType, __assign({ x: pptStyle.x, y: pptStyle.y, w: pptStyle.w, h: pptStyle.h, fill: pptStyle.fill, line: pptStyle.border, rectRadius: pptStyle.rectRadius, rotate: pptStyle.rotate }, (animation ? { animate: { type: animation.type, duration: animation.duration } } : {})));
    }
    // --- 6. 绘制文本 ---
    if (shapes.length > 0) {
        shapes.forEach(function (shape) {
            slide.addText(shape.text, __assign(__assign(__assign({}, shape.options), (animation ? { animate: { type: animation.type, duration: animation.duration } } : {})), { 
                // 继承父级旋转
                rotate: pptStyle.rotate }));
        });
    }
    // --- 递归处理子元素 ---
    Array.from(element.children).forEach(function (child) {
        if (consumedElements.has(child))
            return;
        processElement(child, slide, pageRect, globalScale, pageTransformScale);
    });
}
/**
 * 将 html dom 转换为 pptx 对象
 */
function html2pptx(pageClass) {
    var ppt = new PptxGenJS__default["default"]();
    ppt.layout = "LAYOUT_16x9";
    ppt.theme = { headFontFace: "黑体" };
    var pages = document.querySelectorAll(".".concat(pageClass));
    if (pages.length === 0) {
        console.warn("[html2pptx] \u672A\u627E\u5230\u7C7B\u540D\u4E3A .".concat(pageClass, " \u7684\u5E7B\u706F\u7247\u5143\u7D20"));
        return ppt;
    }
    pages.forEach(function (dom) {
        var element = dom;
        if (element.offsetWidth === 0 || element.offsetHeight === 0)
            return;
        var pageRect = element.getBoundingClientRect();
        var pageTransformScale = pageRect.width / element.offsetWidth;
        if (pageTransformScale === 0)
            return;
        var unscaledPageWidth = element.offsetWidth;
        var globalScale = PPT_LAYOUT.width / unscaledPageWidth;
        var slide = ppt.addSlide();
        var bgStyle = window.getComputedStyle(element);
        var bgImg = bgStyle.backgroundImage;
        var bgColor = colorToHex(bgStyle.backgroundColor);
        if (bgImg && bgImg.includes("url(")) {
            var match = bgImg.match(/url\s*\(['"]?(.*?)['"]?\)/);
            var imageUrl = match && match[1] ? match[1] : undefined;
            slide.addImage({ x: 0, y: 0, w: "100%", h: "100%", path: imageUrl });
        }
        else if (bgColor) {
            // 处理纯色 (如果背景是渐变，通常 computedStyle 的 backgroundColor 会是透明或回退色，这里只取 color)
            slide.background = { color: bgColor };
        }
        // console.log("page:", slide);
        Array.from(element.children).forEach(function (child) {
            processElement(child, slide, pageRect, globalScale, pageTransformScale);
        });
    });
    return ppt;
}

function exportHtmlToPpt(pageClassName, outputType) {
    var _this = this;
    if (pageClassName === void 0) { pageClassName = "page"; }
    if (outputType === void 0) { outputType = "blob"; }
    return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
        var PptxGenJSIns, result, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, html2pptx(pageClassName)];
                case 1:
                    PptxGenJSIns = _a.sent();
                    result = PptxGenJSIns.write({ outputType: outputType });
                    resolve(result);
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    console.error("PPT Generation Error:", error_1);
                    reject(error_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    }); });
}
function downloadHtmlToPpt(pageClassName, fileName) {
    var _this = this;
    if (pageClassName === void 0) { pageClassName = "page"; }
    if (fileName === void 0) { fileName = "presentation"; }
    return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
        var PptxGenJSIns, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, html2pptx(pageClassName)];
                case 1:
                    PptxGenJSIns = _a.sent();
                    PptxGenJSIns.writeFile({ fileName: fileName + ".pptx" });
                    resolve();
                    return [3 /*break*/, 3];
                case 2:
                    error_2 = _a.sent();
                    console.error("PPT Generation Error:", error_2);
                    reject(error_2);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    }); });
}

exports.downloadHtmlToPpt = downloadHtmlToPpt;
exports.exportHtmlToPpt = exportHtmlToPpt;
//# sourceMappingURL=index.js.map
