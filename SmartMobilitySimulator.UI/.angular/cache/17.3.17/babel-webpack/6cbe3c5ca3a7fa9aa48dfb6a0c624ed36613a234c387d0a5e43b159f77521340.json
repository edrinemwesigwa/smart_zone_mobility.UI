{"ast":null,"code":"/**\n * Converts indexed data into RGB/RGBA format\n * @param decodedImage - Image to decode data from.\n * @returns Uint8Array with RGB data.\n */\nexport function convertIndexedToRgb(decodedImage) {\n  const palette = decodedImage.palette;\n  const depth = decodedImage.depth;\n  if (!palette) {\n    throw new Error('Color palette is undefined.');\n  }\n  checkDataSize(decodedImage);\n  const indexSize = decodedImage.width * decodedImage.height;\n  const resSize = indexSize * palette[0].length;\n  const res = new Uint8Array(resSize);\n  let indexPos = 0;\n  let offset = 0;\n  const indexes = new Uint8Array(indexSize);\n  let bit = 0xff;\n  switch (depth) {\n    case 1:\n      bit = 0x80;\n      break;\n    case 2:\n      bit = 0xc0;\n      break;\n    case 4:\n      bit = 0xf0;\n      break;\n    case 8:\n      bit = 0xff;\n      break;\n    default:\n      throw new Error('Incorrect depth value');\n  }\n  for (const byte of decodedImage.data) {\n    let bit2 = bit;\n    let shift = 8;\n    while (bit2) {\n      shift -= depth;\n      indexes[indexPos++] = (byte & bit2) >> shift;\n      bit2 = bit2 >> depth;\n      if (indexPos % decodedImage.width === 0) {\n        break;\n      }\n    }\n  }\n  if (decodedImage.palette) {\n    for (const index of indexes) {\n      const color = decodedImage.palette.at(index);\n      if (!color) {\n        throw new Error('Incorrect index of palette color');\n      }\n      res.set(color, offset);\n      offset += color.length;\n    }\n  }\n  return res;\n}\nfunction checkDataSize(image) {\n  const expectedSize = image.depth < 8 ? Math.ceil(image.width * image.depth / 8) * image.height * image.channels : image.width * image.height * image.channels;\n  if (image.data.length !== expectedSize) {\n    throw new RangeError(`wrong data size. Found ${image.data.length}, expected ${expectedSize}`);\n  }\n}","map":{"version":3,"names":["convertIndexedToRgb","decodedImage","palette","depth","Error","checkDataSize","indexSize","width","height","resSize","length","res","Uint8Array","indexPos","offset","indexes","bit","byte","data","bit2","shift","index","color","at","set","image","expectedSize","Math","ceil","channels","RangeError"],"sources":["C:/Users/edrin/OneDrive/Desktop/Mobility/SmartMobilitySimulator.UI/node_modules/fast-png/lib-esm/convertIndexedToRgb.js"],"sourcesContent":["/**\n * Converts indexed data into RGB/RGBA format\n * @param decodedImage - Image to decode data from.\n * @returns Uint8Array with RGB data.\n */\nexport function convertIndexedToRgb(decodedImage) {\n    const palette = decodedImage.palette;\n    const depth = decodedImage.depth;\n    if (!palette) {\n        throw new Error('Color palette is undefined.');\n    }\n    checkDataSize(decodedImage);\n    const indexSize = decodedImage.width * decodedImage.height;\n    const resSize = indexSize * palette[0].length;\n    const res = new Uint8Array(resSize);\n    let indexPos = 0;\n    let offset = 0;\n    const indexes = new Uint8Array(indexSize);\n    let bit = 0xff;\n    switch (depth) {\n        case 1:\n            bit = 0x80;\n            break;\n        case 2:\n            bit = 0xc0;\n            break;\n        case 4:\n            bit = 0xf0;\n            break;\n        case 8:\n            bit = 0xff;\n            break;\n        default:\n            throw new Error('Incorrect depth value');\n    }\n    for (const byte of decodedImage.data) {\n        let bit2 = bit;\n        let shift = 8;\n        while (bit2) {\n            shift -= depth;\n            indexes[indexPos++] = (byte & bit2) >> shift;\n            bit2 = bit2 >> depth;\n            if (indexPos % decodedImage.width === 0) {\n                break;\n            }\n        }\n    }\n    if (decodedImage.palette) {\n        for (const index of indexes) {\n            const color = decodedImage.palette.at(index);\n            if (!color) {\n                throw new Error('Incorrect index of palette color');\n            }\n            res.set(color, offset);\n            offset += color.length;\n        }\n    }\n    return res;\n}\nfunction checkDataSize(image) {\n    const expectedSize = image.depth < 8\n        ? Math.ceil((image.width * image.depth) / 8) *\n            image.height *\n            image.channels\n        : image.width * image.height * image.channels;\n    if (image.data.length !== expectedSize) {\n        throw new RangeError(`wrong data size. Found ${image.data.length}, expected ${expectedSize}`);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,mBAAmBA,CAACC,YAAY,EAAE;EAC9C,MAAMC,OAAO,GAAGD,YAAY,CAACC,OAAO;EACpC,MAAMC,KAAK,GAAGF,YAAY,CAACE,KAAK;EAChC,IAAI,CAACD,OAAO,EAAE;IACV,MAAM,IAAIE,KAAK,CAAC,6BAA6B,CAAC;EAClD;EACAC,aAAa,CAACJ,YAAY,CAAC;EAC3B,MAAMK,SAAS,GAAGL,YAAY,CAACM,KAAK,GAAGN,YAAY,CAACO,MAAM;EAC1D,MAAMC,OAAO,GAAGH,SAAS,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACQ,MAAM;EAC7C,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACH,OAAO,CAAC;EACnC,IAAII,QAAQ,GAAG,CAAC;EAChB,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,OAAO,GAAG,IAAIH,UAAU,CAACN,SAAS,CAAC;EACzC,IAAIU,GAAG,GAAG,IAAI;EACd,QAAQb,KAAK;IACT,KAAK,CAAC;MACFa,GAAG,GAAG,IAAI;MACV;IACJ,KAAK,CAAC;MACFA,GAAG,GAAG,IAAI;MACV;IACJ,KAAK,CAAC;MACFA,GAAG,GAAG,IAAI;MACV;IACJ,KAAK,CAAC;MACFA,GAAG,GAAG,IAAI;MACV;IACJ;MACI,MAAM,IAAIZ,KAAK,CAAC,uBAAuB,CAAC;EAChD;EACA,KAAK,MAAMa,IAAI,IAAIhB,YAAY,CAACiB,IAAI,EAAE;IAClC,IAAIC,IAAI,GAAGH,GAAG;IACd,IAAII,KAAK,GAAG,CAAC;IACb,OAAOD,IAAI,EAAE;MACTC,KAAK,IAAIjB,KAAK;MACdY,OAAO,CAACF,QAAQ,EAAE,CAAC,GAAG,CAACI,IAAI,GAAGE,IAAI,KAAKC,KAAK;MAC5CD,IAAI,GAAGA,IAAI,IAAIhB,KAAK;MACpB,IAAIU,QAAQ,GAAGZ,YAAY,CAACM,KAAK,KAAK,CAAC,EAAE;QACrC;MACJ;IACJ;EACJ;EACA,IAAIN,YAAY,CAACC,OAAO,EAAE;IACtB,KAAK,MAAMmB,KAAK,IAAIN,OAAO,EAAE;MACzB,MAAMO,KAAK,GAAGrB,YAAY,CAACC,OAAO,CAACqB,EAAE,CAACF,KAAK,CAAC;MAC5C,IAAI,CAACC,KAAK,EAAE;QACR,MAAM,IAAIlB,KAAK,CAAC,kCAAkC,CAAC;MACvD;MACAO,GAAG,CAACa,GAAG,CAACF,KAAK,EAAER,MAAM,CAAC;MACtBA,MAAM,IAAIQ,KAAK,CAACZ,MAAM;IAC1B;EACJ;EACA,OAAOC,GAAG;AACd;AACA,SAASN,aAAaA,CAACoB,KAAK,EAAE;EAC1B,MAAMC,YAAY,GAAGD,KAAK,CAACtB,KAAK,GAAG,CAAC,GAC9BwB,IAAI,CAACC,IAAI,CAAEH,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACtB,KAAK,GAAI,CAAC,CAAC,GACxCsB,KAAK,CAACjB,MAAM,GACZiB,KAAK,CAACI,QAAQ,GAChBJ,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACjB,MAAM,GAAGiB,KAAK,CAACI,QAAQ;EACjD,IAAIJ,KAAK,CAACP,IAAI,CAACR,MAAM,KAAKgB,YAAY,EAAE;IACpC,MAAM,IAAII,UAAU,CAAC,0BAA0BL,KAAK,CAACP,IAAI,CAACR,MAAM,cAAcgB,YAAY,EAAE,CAAC;EACjG;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}