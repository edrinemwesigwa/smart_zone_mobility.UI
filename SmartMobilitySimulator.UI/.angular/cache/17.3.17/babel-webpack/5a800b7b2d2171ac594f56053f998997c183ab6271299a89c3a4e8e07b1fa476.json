{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PngEncoder extends IOBuffer {\n  _png;\n  _zlibOptions;\n  _colorType;\n  _interlaceMethod;\n  constructor(data, options = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = {\n      ...defaultZlibOptions,\n      ...options.zlib\n    };\n    this._png = this._checkData(data);\n    this._interlaceMethod = (options.interlace === 'Adam7' ? InterlaceMethod.ADAM7 : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n    this.setBigEndian();\n  }\n  encode() {\n    writeSignature(this);\n    this.encodeIHDR();\n    if (this._png.palette) {\n      this.encodePLTE();\n      if (this._png.palette[0].length === 4) {\n        this.encodeTRNS();\n      }\n    }\n    this.encodeData();\n    if (this._png.text) {\n      for (const [keyword, text] of Object.entries(this._png.text)) {\n        encodetEXt(this, keyword, text);\n      }\n    }\n    this.encodeIEND();\n    return this.toArray();\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(this._interlaceMethod);\n    writeCrc(this, 17);\n  }\n  // https://www.w3.org/TR/PNG/#11IEND\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    writeCrc(this, 4);\n  }\n  encodePLTE() {\n    const paletteLength = this._png.palette?.length * 3;\n    this.writeUint32(paletteLength);\n    this.writeChars('PLTE');\n    for (const color of this._png.palette) {\n      this.writeByte(color[0]);\n      this.writeByte(color[1]);\n      this.writeByte(color[2]);\n    }\n    writeCrc(this, 4 + paletteLength);\n  }\n  encodeTRNS() {\n    const alpha = this._png.palette.filter(color => {\n      return color.at(-1) !== 255;\n    });\n    this.writeUint32(alpha.length);\n    this.writeChars('tRNS');\n    for (const el of alpha) {\n      this.writeByte(el.at(-1));\n    }\n    writeCrc(this, 4 + alpha.length);\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    writeCrc(this, data.length + 4);\n  }\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = depth <= 8 ? Math.ceil(width * depth / 8) * channels : Math.ceil(width * depth / 8 * channels / 2);\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      for (let i = 0; i < height; i++) {\n        newData.writeByte(0); // no filter\n        if (depth === 16) {\n          offset = writeDataUint16(data, newData, slotsPerLine, offset);\n        } else {\n          offset = writeDataBytes(data, newData, slotsPerLine, offset);\n        }\n      }\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      // Adam7 interlacing\n      offset = writeDataInterlaced(this._png, data, newData, offset);\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data, data.palette);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: data.text,\n      palette: data.palette\n    };\n    this._colorType = colorType;\n    const expectedSize = depth < 8 ? Math.ceil(png.width * depth / 8) * png.height * channels : png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n    }\n    return png;\n  }\n}\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      if (palette) {\n        returnValue.colorType = ColorType.INDEXED_COLOUR;\n      } else {\n        returnValue.colorType = ColorType.GREYSCALE;\n      }\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n  const passes = [{\n    x: 0,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 4,\n    y: 0,\n    xStep: 8,\n    yStep: 8\n  }, {\n    x: 0,\n    y: 4,\n    xStep: 4,\n    yStep: 8\n  }, {\n    x: 2,\n    y: 0,\n    xStep: 4,\n    yStep: 4\n  }, {\n    x: 0,\n    y: 2,\n    xStep: 2,\n    yStep: 4\n  }, {\n    x: 1,\n    y: 0,\n    xStep: 2,\n    yStep: 2\n  }, {\n    x: 0,\n    y: 1,\n    xStep: 1,\n    yStep: 2\n  }];\n  const {\n    width,\n    height,\n    channels,\n    depth\n  } = imageData;\n  let pixelSize = 0;\n  if (depth === 16) {\n    pixelSize = channels * depth / 8 / 2;\n  } else {\n    pixelSize = channels * depth / 8;\n  }\n  // Process each pass\n  for (let passIndex = 0; passIndex < 7; passIndex++) {\n    const pass = passes[passIndex];\n    const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n    const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n    if (passWidth <= 0 || passHeight <= 0) continue;\n    const passLineBytes = passWidth * pixelSize;\n    // For each scanline in this pass\n    for (let y = 0; y < passHeight; y++) {\n      const imageY = pass.y + y * pass.yStep;\n      // Extract raw scanline data\n      const rawScanline = depth <= 8 ? new Uint8Array(passLineBytes) : new Uint16Array(passLineBytes);\n      let rawOffset = 0;\n      for (let x = 0; x < passWidth; x++) {\n        const imageX = pass.x + x * pass.xStep;\n        if (imageX < width && imageY < height) {\n          const srcPos = (imageY * width + imageX) * pixelSize;\n          for (let i = 0; i < pixelSize; i++) {\n            rawScanline[rawOffset++] = data[srcPos + i];\n          }\n        }\n      }\n      newData.writeByte(0); // no filter\n      if (depth === 8) {\n        newData.writeBytes(rawScanline);\n      } else if (depth === 16) {\n        for (const value of rawScanline) {\n          newData.writeByte(value >> 8 & 0xff); // High byte\n          newData.writeByte(value & 0xff);\n        }\n      }\n    }\n  }\n  return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}","map":{"version":3,"names":["IOBuffer","deflate","writeCrc","writeSignature","encodetEXt","InterlaceMethod","ColorType","CompressionMethod","FilterMethod","defaultZlibOptions","level","PngEncoder","_png","_zlibOptions","_colorType","_interlaceMethod","constructor","data","options","UNKNOWN","zlib","_checkData","interlace","ADAM7","NO_INTERLACE","setBigEndian","encode","encodeIHDR","palette","encodePLTE","length","encodeTRNS","encodeData","text","keyword","Object","entries","encodeIEND","toArray","writeUint32","writeChars","width","height","writeByte","depth","DEFLATE","ADAPTIVE","paletteLength","color","alpha","filter","at","el","encodeIDAT","writeBytes","channels","slotsPerLine","Math","ceil","newData","offset","i","writeDataUint16","writeDataBytes","writeDataInterlaced","buffer","compressed","colorType","getColorType","png","checkInteger","expectedSize","RangeError","value","name","Number","isInteger","TypeError","returnValue","TRUECOLOUR_ALPHA","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE","GREYSCALE_ALPHA","Error","j","imageData","passes","x","y","xStep","yStep","pixelSize","passIndex","pass","passWidth","floor","passHeight","passLineBytes","imageY","rawScanline","Uint8Array","Uint16Array","rawOffset","imageX","srcPos","writeUint16"],"sources":["C:/Users/edrin/OneDrive/Desktop/Mobility/SmartMobilitySimulator.UI/node_modules/fast-png/lib-esm/PngEncoder.js"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from './helpers/crc';\nimport { writeSignature } from './helpers/signature';\nimport { encodetEXt } from './helpers/text';\nimport { InterlaceMethod, ColorType, CompressionMethod, FilterMethod, } from './internalTypes';\nconst defaultZlibOptions = {\n    level: 3,\n};\nexport default class PngEncoder extends IOBuffer {\n    _png;\n    _zlibOptions;\n    _colorType;\n    _interlaceMethod;\n    constructor(data, options = {}) {\n        super();\n        this._colorType = ColorType.UNKNOWN;\n        this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n        this._png = this._checkData(data);\n        this._interlaceMethod =\n            (options.interlace === 'Adam7'\n                ? InterlaceMethod.ADAM7\n                : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n        this.setBigEndian();\n    }\n    encode() {\n        writeSignature(this);\n        this.encodeIHDR();\n        if (this._png.palette) {\n            this.encodePLTE();\n            if (this._png.palette[0].length === 4) {\n                this.encodeTRNS();\n            }\n        }\n        this.encodeData();\n        if (this._png.text) {\n            for (const [keyword, text] of Object.entries(this._png.text)) {\n                encodetEXt(this, keyword, text);\n            }\n        }\n        this.encodeIEND();\n        return this.toArray();\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    encodeIHDR() {\n        this.writeUint32(13);\n        this.writeChars('IHDR');\n        this.writeUint32(this._png.width);\n        this.writeUint32(this._png.height);\n        this.writeByte(this._png.depth);\n        this.writeByte(this._colorType);\n        this.writeByte(CompressionMethod.DEFLATE);\n        this.writeByte(FilterMethod.ADAPTIVE);\n        this.writeByte(this._interlaceMethod);\n        writeCrc(this, 17);\n    }\n    // https://www.w3.org/TR/PNG/#11IEND\n    encodeIEND() {\n        this.writeUint32(0);\n        this.writeChars('IEND');\n        writeCrc(this, 4);\n    }\n    encodePLTE() {\n        const paletteLength = this._png.palette?.length * 3;\n        this.writeUint32(paletteLength);\n        this.writeChars('PLTE');\n        for (const color of this._png.palette) {\n            this.writeByte(color[0]);\n            this.writeByte(color[1]);\n            this.writeByte(color[2]);\n        }\n        writeCrc(this, 4 + paletteLength);\n    }\n    encodeTRNS() {\n        const alpha = this._png.palette.filter((color) => {\n            return color.at(-1) !== 255;\n        });\n        this.writeUint32(alpha.length);\n        this.writeChars('tRNS');\n        for (const el of alpha) {\n            this.writeByte(el.at(-1));\n        }\n        writeCrc(this, 4 + alpha.length);\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    encodeIDAT(data) {\n        this.writeUint32(data.length);\n        this.writeChars('IDAT');\n        this.writeBytes(data);\n        writeCrc(this, data.length + 4);\n    }\n    encodeData() {\n        const { width, height, channels, depth, data } = this._png;\n        const slotsPerLine = depth <= 8\n            ? Math.ceil((width * depth) / 8) * channels\n            : Math.ceil((((width * depth) / 8) * channels) / 2);\n        const newData = new IOBuffer().setBigEndian();\n        let offset = 0;\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            for (let i = 0; i < height; i++) {\n                newData.writeByte(0); // no filter\n                if (depth === 16) {\n                    offset = writeDataUint16(data, newData, slotsPerLine, offset);\n                }\n                else {\n                    offset = writeDataBytes(data, newData, slotsPerLine, offset);\n                }\n            }\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            // Adam7 interlacing\n            offset = writeDataInterlaced(this._png, data, newData, offset);\n        }\n        const buffer = newData.toArray();\n        const compressed = deflate(buffer, this._zlibOptions);\n        this.encodeIDAT(compressed);\n    }\n    _checkData(data) {\n        const { colorType, channels, depth } = getColorType(data, data.palette);\n        const png = {\n            width: checkInteger(data.width, 'width'),\n            height: checkInteger(data.height, 'height'),\n            channels,\n            data: data.data,\n            depth,\n            text: data.text,\n            palette: data.palette,\n        };\n        this._colorType = colorType;\n        const expectedSize = depth < 8\n            ? Math.ceil((png.width * depth) / 8) * png.height * channels\n            : png.width * png.height * channels;\n        if (png.data.length !== expectedSize) {\n            throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n        }\n        return png;\n    }\n}\nfunction checkInteger(value, name) {\n    if (Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n    const { channels = 4, depth = 8 } = data;\n    if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n        throw new RangeError(`unsupported number of channels: ${channels}`);\n    }\n    const returnValue = {\n        channels,\n        depth,\n        colorType: ColorType.UNKNOWN,\n    };\n    switch (channels) {\n        case 4:\n            returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n            break;\n        case 3:\n            returnValue.colorType = ColorType.TRUECOLOUR;\n            break;\n        case 1:\n            if (palette) {\n                returnValue.colorType = ColorType.INDEXED_COLOUR;\n            }\n            else {\n                returnValue.colorType = ColorType.GREYSCALE;\n            }\n            break;\n        case 2:\n            returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n            break;\n        default:\n            throw new Error('unsupported number of channels');\n    }\n    return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeByte(data[offset++]);\n    }\n    return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n    const passes = [\n        { x: 0, y: 0, xStep: 8, yStep: 8 },\n        { x: 4, y: 0, xStep: 8, yStep: 8 },\n        { x: 0, y: 4, xStep: 4, yStep: 8 },\n        { x: 2, y: 0, xStep: 4, yStep: 4 },\n        { x: 0, y: 2, xStep: 2, yStep: 4 },\n        { x: 1, y: 0, xStep: 2, yStep: 2 },\n        { x: 0, y: 1, xStep: 1, yStep: 2 },\n    ];\n    const { width, height, channels, depth } = imageData;\n    let pixelSize = 0;\n    if (depth === 16) {\n        pixelSize = (channels * depth) / 8 / 2;\n    }\n    else {\n        pixelSize = (channels * depth) / 8;\n    }\n    // Process each pass\n    for (let passIndex = 0; passIndex < 7; passIndex++) {\n        const pass = passes[passIndex];\n        const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n        const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n        if (passWidth <= 0 || passHeight <= 0)\n            continue;\n        const passLineBytes = passWidth * pixelSize;\n        // For each scanline in this pass\n        for (let y = 0; y < passHeight; y++) {\n            const imageY = pass.y + y * pass.yStep;\n            // Extract raw scanline data\n            const rawScanline = depth <= 8\n                ? new Uint8Array(passLineBytes)\n                : new Uint16Array(passLineBytes);\n            let rawOffset = 0;\n            for (let x = 0; x < passWidth; x++) {\n                const imageX = pass.x + x * pass.xStep;\n                if (imageX < width && imageY < height) {\n                    const srcPos = (imageY * width + imageX) * pixelSize;\n                    for (let i = 0; i < pixelSize; i++) {\n                        rawScanline[rawOffset++] = data[srcPos + i];\n                    }\n                }\n            }\n            newData.writeByte(0); // no filter\n            if (depth === 8) {\n                newData.writeBytes(rawScanline);\n            }\n            else if (depth === 16) {\n                for (const value of rawScanline) {\n                    newData.writeByte((value >> 8) & 0xff); // High byte\n                    newData.writeByte(value & 0xff);\n                }\n            }\n        }\n    }\n    return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeUint16(data[offset++]);\n    }\n    return offset;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}