{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/edrin/OneDrive/Desktop/Mobility/SmartZoneSimulator.UI/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as L from \"leaflet\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./traffic-api.service\";\nexport let TrafficLayerService = /*#__PURE__*/(() => {\n  class TrafficLayerService {\n    constructor(trafficApi) {\n      this.trafficApi = trafficApi;\n      this.map = null;\n      this.trafficLayer = null;\n      this.heatmapLayer = null;\n      this.speedLayer = null;\n      this.flowLayer = null;\n      this.incidentLayer = null;\n      this.overlayLayer = null;\n      this.liveRefreshHandle = null;\n    }\n    isLiveAvailable() {\n      return this.trafficApi.isLiveAvailable();\n    }\n    initialize(map) {\n      this.map = map;\n      this.trafficLayer = L.layerGroup().addTo(map);\n      this.speedLayer = L.layerGroup().addTo(map);\n      this.flowLayer = L.layerGroup().addTo(map);\n      this.incidentLayer = L.layerGroup().addTo(map);\n      this.overlayLayer = L.layerGroup().addTo(map);\n      const heatLayerFactory = L.heatLayer;\n      if (heatLayerFactory) {\n        this.heatmapLayer = heatLayerFactory([], {\n          radius: 25,\n          blur: 18,\n          maxZoom: 13\n        }).addTo(map);\n      } else {\n        this.heatmapLayer = L.layerGroup().addTo(map);\n      }\n    }\n    clear() {\n      this.trafficLayer?.clearLayers();\n      this.speedLayer?.clearLayers();\n      this.flowLayer?.clearLayers();\n      this.incidentLayer?.clearLayers();\n      this.overlayLayer?.clearLayers();\n      if (this.heatmapLayer?.setLatLngs) {\n        this.heatmapLayer.setLatLngs([]);\n      } else if (this.heatmapLayer?.clearLayers) {\n        this.heatmapLayer.clearLayers();\n      }\n    }\n    stopLiveUpdates() {\n      if (this.liveRefreshHandle) {\n        window.clearInterval(this.liveRefreshHandle);\n        this.liveRefreshHandle = null;\n      }\n    }\n    startLiveUpdates(zone, boundingBox) {\n      this.stopLiveUpdates();\n      this.showLiveTraffic(zone, boundingBox);\n      this.liveRefreshHandle = window.setInterval(() => {\n        this.showLiveTraffic(zone, boundingBox);\n      }, 5 * 60 * 1000);\n    }\n    showLiveTraffic(zone, boundingBox) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const traffic = yield _this.trafficApi.getLiveTraffic(zone.id);\n        _this.renderTraffic(traffic, zone, boundingBox);\n      })();\n    }\n    showHistoricalPattern(zone, time, boundingBox) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const pattern = yield _this2.trafficApi.getHistoricalPattern(zone.id, time);\n        _this2.renderHistorical(pattern, zone, time, boundingBox);\n      })();\n    }\n    showSimulationResults(zone, time, boundingBox) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const pattern = yield _this3.trafficApi.getHistoricalPattern(zone.id, time);\n        _this3.renderHistorical(pattern, zone, time, boundingBox, true);\n      })();\n    }\n    renderTraffic(traffic, zone, boundingBox) {\n      this.clear();\n      const center = this.getZoneCenter(zone);\n      const bounds = this.getBoundingBox(boundingBox, center);\n      const segments = this.inflateSegments(traffic.segments, bounds);\n      const heatPoints = this.convertSegmentsToHeatmap(segments);\n      this.setHeatmapPoints(heatPoints);\n      this.addFlowLines(segments);\n      this.addSpeedIndicators(segments);\n      this.addIncidents(traffic.incidents, center, bounds);\n    }\n    renderHistorical(pattern, zone, time, boundingBox, isSimulation = false) {\n      this.clear();\n      const center = this.getZoneCenter(zone);\n      const bounds = this.getBoundingBox(boundingBox, center);\n      const segments = this.inflateSegments(pattern.segments, bounds);\n      const heatPoints = this.convertSegmentsToHeatmap(segments);\n      this.setHeatmapPoints(heatPoints);\n      this.addFlowLines(segments, isSimulation);\n      this.addSpeedIndicators(segments);\n      this.addIncidents(pattern.incidents, center, bounds);\n      if (this.isPrayerTime(time)) {\n        this.addPrayerTimeOverlay(center);\n      }\n      if (this.isSchoolTime(time)) {\n        this.highlightSchoolZones(center);\n      }\n      if (this.isConstructionSeason(time)) {\n        this.addConstructionWarnings(center);\n      }\n    }\n    setHeatmapPoints(points) {\n      if (this.heatmapLayer?.setLatLngs) {\n        this.heatmapLayer.setLatLngs(points);\n        return;\n      }\n      if (this.heatmapLayer?.clearLayers) {\n        this.heatmapLayer.clearLayers();\n        points.forEach(([lat, lng, intensity]) => {\n          const circle = L.circleMarker([lat, lng], {\n            radius: 8 + intensity * 8,\n            fillColor: \"#F44336\",\n            fillOpacity: Math.min(0.7, 0.2 + intensity * 0.5),\n            stroke: false\n          });\n          circle.addTo(this.heatmapLayer);\n        });\n      }\n    }\n    convertSegmentsToHeatmap(segments) {\n      return segments.flatMap(segment => {\n        const intensity = Math.min(1, Math.max(0.1, segment.congestionLevel / 100));\n        return segment.path.map(point => [point[0], point[1], intensity]);\n      });\n    }\n    addSpeedIndicators(segments) {\n      if (!this.speedLayer) return;\n      segments.forEach(segment => {\n        const mid = this.getSegmentMidpoint(segment.path);\n        if (!mid) return;\n        const marker = L.marker([mid[0], mid[1]], {\n          icon: L.divIcon({\n            className: \"speed-indicator\",\n            html: `<span>${Math.round(segment.speed)} km/h</span>`\n          })\n        });\n        marker.addTo(this.speedLayer);\n      });\n    }\n    addFlowLines(segments, isSimulation = false) {\n      if (!this.flowLayer) return;\n      segments.forEach(segment => {\n        const color = this.getCongestionColor(segment.congestionLevel);\n        const polyline = L.polyline(segment.path, {\n          color,\n          weight: 4,\n          opacity: isSimulation ? 0.7 : 0.9,\n          dashArray: \"8 10\",\n          className: \"traffic-flow\"\n        });\n        polyline.addTo(this.flowLayer);\n      });\n    }\n    addIncidents(incidents, center, bounds) {\n      if (!this.incidentLayer) return;\n      const seeded = incidents.length > 0 ? incidents : this.generateIncidents(center, bounds);\n      seeded.forEach(incident => {\n        const marker = L.marker([incident.latitude, incident.longitude], {\n          icon: L.divIcon({\n            className: `incident-marker ${incident.severity.toLowerCase()}`,\n            html: `<span>${incident.type}</span>`\n          })\n        });\n        marker.bindPopup(`<strong>${incident.type}</strong><br/>${incident.description}`);\n        marker.addTo(this.incidentLayer);\n      });\n    }\n    addPrayerTimeOverlay(center) {\n      if (!this.overlayLayer) return;\n      const circle = L.circle(center, {\n        radius: 2200,\n        color: \"#5C6BC0\",\n        weight: 2,\n        fillOpacity: 0.08,\n        dashArray: \"6 6\"\n      });\n      circle.bindTooltip(\"Prayer time: reduced traffic\", {\n        permanent: false\n      });\n      circle.addTo(this.overlayLayer);\n    }\n    highlightSchoolZones(center) {\n      if (!this.overlayLayer) return;\n      const offsets = [0.01, -0.012, 0.014];\n      offsets.forEach((offset, index) => {\n        const marker = L.marker([center.lat + offset, center.lng - offset], {\n          icon: L.divIcon({\n            className: \"school-zone-marker\",\n            html: `<span>School ${index + 1}</span>`\n          })\n        });\n        marker.addTo(this.overlayLayer);\n      });\n    }\n    addConstructionWarnings(center) {\n      if (!this.overlayLayer) return;\n      const marker = L.marker([center.lat - 0.015, center.lng + 0.012], {\n        icon: L.divIcon({\n          className: \"construction-marker\",\n          html: \"<span>Construction</span>\"\n        })\n      });\n      marker.addTo(this.overlayLayer);\n    }\n    inflateSegments(segments, bounds) {\n      if (segments.length === 0) {\n        return this.generateSegments(bounds);\n      }\n      return segments.map(segment => ({\n        ...segment,\n        path: segment.path.length > 1 ? segment.path : this.randomPath(bounds)\n      }));\n    }\n    generateSegments(bounds) {\n      const directions = [\"N\", \"S\", \"E\", \"W\"];\n      return directions.map((direction, index) => ({\n        id: `auto-${index}`,\n        path: this.randomPath(bounds),\n        speed: 25 + index * 6,\n        congestionLevel: 40 + index * 10,\n        flowDirection: direction\n      }));\n    }\n    randomPath(bounds) {\n      const start = this.randomPoint(bounds);\n      const end = this.randomPoint(bounds);\n      return [start, end];\n    }\n    randomPoint(bounds) {\n      const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());\n      const lng = bounds.getWest() + Math.random() * (bounds.getEast() - bounds.getWest());\n      return [lat, lng];\n    }\n    getSegmentMidpoint(path) {\n      if (path.length === 0) return null;\n      const midIndex = Math.floor(path.length / 2);\n      return path[midIndex];\n    }\n    getZoneCenter(zone) {\n      if (typeof zone.latitude === \"number\" && typeof zone.longitude === \"number\") {\n        return L.latLng(zone.latitude, zone.longitude);\n      }\n      return this.map?.getCenter() ?? L.latLng(24.4539, 54.3773);\n    }\n    getBoundingBox(boundingBox, center) {\n      if (boundingBox) {\n        const parts = boundingBox.split(\",\").map(p => Number(p));\n        if (parts.length === 4 && parts.every(p => !Number.isNaN(p))) {\n          return L.latLngBounds([parts[1], parts[0]], [parts[3], parts[2]]);\n        }\n      }\n      const delta = 0.05;\n      return L.latLngBounds([center.lat - delta, center.lng - delta], [center.lat + delta, center.lng + delta]);\n    }\n    getCongestionColor(congestion) {\n      if (congestion < 35) return \"#4CAF50\";\n      if (congestion < 70) return \"#FFC107\";\n      return \"#F44336\";\n    }\n    generateIncidents(center, bounds) {\n      return [{\n        id: \"mock-incident-1\",\n        type: \"Accident\",\n        description: \"Minor collision, right lane blocked\",\n        severity: \"Medium\",\n        latitude: center.lat + 0.01,\n        longitude: center.lng - 0.012\n      }, {\n        id: \"mock-incident-2\",\n        type: \"Roadworks\",\n        description: \"Road maintenance - expect delays\",\n        severity: \"Low\",\n        latitude: bounds.getSouth() + (bounds.getNorth() - bounds.getSouth()) * 0.3,\n        longitude: bounds.getWest() + (bounds.getEast() - bounds.getWest()) * 0.6\n      }];\n    }\n    isPrayerTime(time) {\n      const hour = time.getHours();\n      const day = time.getDay();\n      if (day === 5) {\n        return hour >= 12 && hour < 13;\n      }\n      return hour >= 12 && hour < 13 || hour >= 15 && hour < 16;\n    }\n    isSchoolTime(time) {\n      const hour = time.getHours();\n      const day = time.getDay();\n      if (day === 5 || day === 6) return false;\n      return hour >= 7 && hour <= 9;\n    }\n    isConstructionSeason(time) {\n      return time.getMonth() >= 6 && time.getMonth() <= 9;\n    }\n    static {\n      this.ɵfac = function TrafficLayerService_Factory(t) {\n        return new (t || TrafficLayerService)(i0.ɵɵinject(i1.TrafficApiService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: TrafficLayerService,\n        factory: TrafficLayerService.ɵfac,\n        providedIn: \"root\"\n      });\n    }\n  }\n  return TrafficLayerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}