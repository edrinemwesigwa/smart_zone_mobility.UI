{"ast":null,"code":"import { Observable } from \"rxjs\";\nimport * as i0 from \"@angular/core\";\nexport class UndoRedoService {\n  constructor() {\n    this.historyStack = new Map();\n    this.maxHistorySize = 50;\n  }\n  /**\n   * Initialize a new undo/redo stack for a given key\n   */\n  initialize(key, initialState) {\n    this.historyStack.set(key, {\n      past: [],\n      present: initialState,\n      future: []\n    });\n  }\n  /**\n   * Push a new state to the stack (called after making changes)\n   */\n  push(key, newState) {\n    const state = this.historyStack.get(key);\n    if (!state) {\n      this.initialize(key, newState);\n      return;\n    }\n    // Don't push if state hasn't changed\n    if (JSON.stringify(state.present) === JSON.stringify(newState)) {\n      return;\n    }\n    // Add current state to past\n    const newPast = [...state.past, state.present];\n    // Limit history size\n    if (newPast.length > this.maxHistorySize) {\n      newPast.shift();\n    }\n    this.historyStack.set(key, {\n      past: newPast,\n      present: newState,\n      future: [] // Clear future on new action\n    });\n  }\n  /**\n   * Undo the last action\n   */\n  undo(key) {\n    const state = this.historyStack.get(key);\n    if (!state || state.past.length === 0) {\n      return null;\n    }\n    const newPast = [...state.past];\n    const previousState = newPast.pop();\n    this.historyStack.set(key, {\n      past: newPast,\n      present: previousState,\n      future: [state.present, ...state.future]\n    });\n    return previousState;\n  }\n  /**\n   * Redo the last undone action\n   */\n  redo(key) {\n    const state = this.historyStack.get(key);\n    if (!state || state.future.length === 0) {\n      return null;\n    }\n    const newFuture = [...state.future];\n    const nextState = newFuture.shift();\n    this.historyStack.set(key, {\n      past: [...state.past, state.present],\n      present: nextState,\n      future: newFuture\n    });\n    return nextState;\n  }\n  /**\n   * Get current state\n   */\n  getPresent(key) {\n    const state = this.historyStack.get(key);\n    return state ? state.present : null;\n  }\n  /**\n   * Check if undo is available\n   */\n  canUndo(key) {\n    const state = this.historyStack.get(key);\n    return state ? state.past.length > 0 : false;\n  }\n  /**\n   * Check if redo is available\n   */\n  canRedo(key) {\n    const state = this.historyStack.get(key);\n    return state ? state.future.length > 0 : false;\n  }\n  /**\n   * Get the number of undo steps available\n   */\n  getUndoCount(key) {\n    const state = this.historyStack.get(key);\n    return state ? state.past.length : 0;\n  }\n  /**\n   * Get the number of redo steps available\n   */\n  getRedoCount(key) {\n    const state = this.historyStack.get(key);\n    return state ? state.future.length : 0;\n  }\n  /**\n   * Clear history for a key\n   */\n  clear(key) {\n    this.historyStack.delete(key);\n  }\n  /**\n   * Clear all history\n   */\n  clearAll() {\n    this.historyStack.clear();\n  }\n  /**\n   * Create observable for undo/redo availability\n   */\n  getUndoRedoState(key) {\n    return new Observable(subscriber => {\n      const checkState = () => {\n        subscriber.next({\n          canUndo: this.canUndo(key),\n          canRedo: this.canRedo(key)\n        });\n      };\n      checkState();\n      // Subscribe to storage events for cross-tab sync\n      const handler = e => {\n        if (e.key === `undo-redo-${key}`) {\n          checkState();\n        }\n      };\n      window.addEventListener(\"storage\", handler);\n      return () => {\n        window.removeEventListener(\"storage\", handler);\n      };\n    });\n  }\n  static {\n    this.ɵfac = function UndoRedoService_Factory(t) {\n      return new (t || UndoRedoService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: UndoRedoService,\n      factory: UndoRedoService.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n}","map":{"version":3,"names":["Observable","UndoRedoService","constructor","historyStack","Map","maxHistorySize","initialize","key","initialState","set","past","present","future","push","newState","state","get","JSON","stringify","newPast","length","shift","undo","previousState","pop","redo","newFuture","nextState","getPresent","canUndo","canRedo","getUndoCount","getRedoCount","clear","delete","clearAll","getUndoRedoState","subscriber","checkState","next","handler","e","window","addEventListener","removeEventListener","factory","ɵfac","providedIn"],"sources":["C:\\Users\\edrin\\OneDrive\\Desktop\\Mobility\\SmartMobilitySimulator.UI\\src\\app\\services\\undo-redo.service.ts"],"sourcesContent":["import { Injectable } from \"@angular/core\";\r\nimport { BehaviorSubject, Observable } from \"rxjs\";\r\n\r\nexport interface UndoRedoState<T> {\r\n  past: T[];\r\n  present: T;\r\n  future: T[];\r\n}\r\n\r\n@Injectable({\r\n  providedIn: \"root\",\r\n})\r\nexport class UndoRedoService {\r\n  private historyStack = new Map<string, UndoRedoState<any>>();\r\n  private maxHistorySize = 50;\r\n\r\n  /**\r\n   * Initialize a new undo/redo stack for a given key\r\n   */\r\n  initialize<T>(key: string, initialState: T): void {\r\n    this.historyStack.set(key, {\r\n      past: [],\r\n      present: initialState,\r\n      future: [],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Push a new state to the stack (called after making changes)\r\n   */\r\n  push<T>(key: string, newState: T): void {\r\n    const state = this.historyStack.get(key) as UndoRedoState<T>;\r\n    if (!state) {\r\n      this.initialize(key, newState);\r\n      return;\r\n    }\r\n\r\n    // Don't push if state hasn't changed\r\n    if (JSON.stringify(state.present) === JSON.stringify(newState)) {\r\n      return;\r\n    }\r\n\r\n    // Add current state to past\r\n    const newPast = [...state.past, state.present];\r\n\r\n    // Limit history size\r\n    if (newPast.length > this.maxHistorySize) {\r\n      newPast.shift();\r\n    }\r\n\r\n    this.historyStack.set(key, {\r\n      past: newPast,\r\n      present: newState,\r\n      future: [], // Clear future on new action\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Undo the last action\r\n   */\r\n  undo<T>(key: string): T | null {\r\n    const state = this.historyStack.get(key) as UndoRedoState<T>;\r\n    if (!state || state.past.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const newPast = [...state.past];\r\n    const previousState = newPast.pop()!;\r\n\r\n    this.historyStack.set(key, {\r\n      past: newPast,\r\n      present: previousState,\r\n      future: [state.present, ...state.future],\r\n    });\r\n\r\n    return previousState;\r\n  }\r\n\r\n  /**\r\n   * Redo the last undone action\r\n   */\r\n  redo<T>(key: string): T | null {\r\n    const state = this.historyStack.get(key) as UndoRedoState<T>;\r\n    if (!state || state.future.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const newFuture = [...state.future];\r\n    const nextState = newFuture.shift()!;\r\n\r\n    this.historyStack.set(key, {\r\n      past: [...state.past, state.present],\r\n      present: nextState,\r\n      future: newFuture,\r\n    });\r\n\r\n    return nextState;\r\n  }\r\n\r\n  /**\r\n   * Get current state\r\n   */\r\n  getPresent<T>(key: string): T | null {\r\n    const state = this.historyStack.get(key) as UndoRedoState<T>;\r\n    return state ? state.present : null;\r\n  }\r\n\r\n  /**\r\n   * Check if undo is available\r\n   */\r\n  canUndo(key: string): boolean {\r\n    const state = this.historyStack.get(key);\r\n    return state ? state.past.length > 0 : false;\r\n  }\r\n\r\n  /**\r\n   * Check if redo is available\r\n   */\r\n  canRedo(key: string): boolean {\r\n    const state = this.historyStack.get(key);\r\n    return state ? state.future.length > 0 : false;\r\n  }\r\n\r\n  /**\r\n   * Get the number of undo steps available\r\n   */\r\n  getUndoCount(key: string): number {\r\n    const state = this.historyStack.get(key);\r\n    return state ? state.past.length : 0;\r\n  }\r\n\r\n  /**\r\n   * Get the number of redo steps available\r\n   */\r\n  getRedoCount(key: string): number {\r\n    const state = this.historyStack.get(key);\r\n    return state ? state.future.length : 0;\r\n  }\r\n\r\n  /**\r\n   * Clear history for a key\r\n   */\r\n  clear(key: string): void {\r\n    this.historyStack.delete(key);\r\n  }\r\n\r\n  /**\r\n   * Clear all history\r\n   */\r\n  clearAll(): void {\r\n    this.historyStack.clear();\r\n  }\r\n\r\n  /**\r\n   * Create observable for undo/redo availability\r\n   */\r\n  getUndoRedoState(\r\n    key: string,\r\n  ): Observable<{ canUndo: boolean; canRedo: boolean }> {\r\n    return new Observable((subscriber) => {\r\n      const checkState = () => {\r\n        subscriber.next({\r\n          canUndo: this.canUndo(key),\r\n          canRedo: this.canRedo(key),\r\n        });\r\n      };\r\n\r\n      checkState();\r\n\r\n      // Subscribe to storage events for cross-tab sync\r\n      const handler = (e: StorageEvent) => {\r\n        if (e.key === `undo-redo-${key}`) {\r\n          checkState();\r\n        }\r\n      };\r\n      window.addEventListener(\"storage\", handler);\r\n\r\n      return () => {\r\n        window.removeEventListener(\"storage\", handler);\r\n      };\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}