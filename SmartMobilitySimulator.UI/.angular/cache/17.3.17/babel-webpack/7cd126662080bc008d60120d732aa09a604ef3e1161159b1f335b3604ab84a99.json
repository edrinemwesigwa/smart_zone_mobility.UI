{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n  _checkCrc;\n  _inflator;\n  _png;\n  _apng;\n  _end;\n  _hasPalette;\n  _palette;\n  _hasTransparency;\n  _transparency;\n  _compressionMethod;\n  _filterMethod;\n  _interlaceMethod;\n  _colorType;\n  _isAnimated;\n  _numberOfFrames;\n  _numberOfPlays;\n  _frames;\n  _writingDataChunks;\n  constructor(data, options = {}) {\n    super(data);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._apng = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      depth: 1,\n      numberOfFrames: 1,\n      numberOfPlays: 0,\n      text: {},\n      frames: []\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    this._isAnimated = false;\n    this._numberOfFrames = 1;\n    this._numberOfPlays = 0;\n    this._frames = [];\n    this._writingDataChunks = false;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n  decode() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeChunk(length, type);\n    }\n    this.decodeImage();\n    return this._png;\n  }\n  decodeApng() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeApngChunk(length, type);\n    }\n    this.decodeApngImage();\n    return this._apng;\n  }\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  decodeChunk(length, type) {\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP':\n        // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case textChunkName:\n        // 11.3.4.3 tEXt Textual data\n        decodetEXt(this._png.text, this, length);\n        break;\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  decodeApngChunk(length, type) {\n    const offset = this.offset;\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n      this.pushDataToFrame();\n    }\n    switch (type) {\n      case 'acTL':\n        this.decodeACTL();\n        break;\n      case 'fcTL':\n        this.decodeFCTL();\n        break;\n      case 'fdAT':\n        this.decodeFDAT(length);\n        break;\n      default:\n        this.decodeChunk(length, type);\n        this.offset = offset + length;\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      // Kept for exhaustiveness.\n      // eslint-disable-next-line unicorn/no-useless-switch-case\n      case ColorType.UNKNOWN:\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n    }\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n  decodeACTL() {\n    this._numberOfFrames = this.readUint32();\n    this._numberOfPlays = this.readUint32();\n    this._isAnimated = true;\n  }\n  decodeFCTL() {\n    const image = {\n      sequenceNumber: this.readUint32(),\n      width: this.readUint32(),\n      height: this.readUint32(),\n      xOffset: this.readUint32(),\n      yOffset: this.readUint32(),\n      delayNumber: this.readUint16(),\n      delayDenominator: this.readUint16(),\n      disposeOp: this.readUint8(),\n      blendOp: this.readUint8(),\n      data: new Uint8Array(0)\n    };\n    this._frames.push(image);\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  decodeIDAT(length) {\n    this._writingDataChunks = true;\n    const dataLength = length;\n    const dataOffset = this.offset + this.byteOffset;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  decodeFDAT(length) {\n    this._writingDataChunks = true;\n    let dataLength = length;\n    let dataOffset = this.offset + this.byteOffset;\n    dataOffset += 4;\n    dataLength -= 4;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  // https://www.w3.org/TR/PNG/#11tRNS\n  decodetRNS(length) {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR:\n        {\n          if (length % 2 !== 0) {\n            throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n          }\n          if (length / 2 > this._png.width * this._png.height) {\n            throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n          }\n          this._hasTransparency = true;\n          this._transparency = new Uint16Array(length / 2);\n          for (let i = 0; i < length / 2; i++) {\n            this._transparency[i] = this.readUint16();\n          }\n          break;\n        }\n      case ColorType.INDEXED_COLOUR:\n        {\n          if (length > this._palette.length) {\n            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n          }\n          let i = 0;\n          for (; i < length; i++) {\n            const alpha = this.readByte();\n            this._palette[i].push(alpha);\n          }\n          for (; i < this._palette.length; i++) {\n            this._palette[i].push(255);\n          }\n          break;\n        }\n      // Kept for exhaustiveness.\n      /* eslint-disable unicorn/no-useless-switch-case */\n      case ColorType.UNKNOWN:\n      case ColorType.GREYSCALE_ALPHA:\n      case ColorType.TRUECOLOUR_ALPHA:\n      default:\n        {\n          throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n        }\n      /* eslint-enable unicorn/no-useless-switch-case */\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11iCCP\n  decodeiCCP(length) {\n    const name = readKeyword(this);\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile)\n    };\n  }\n  // https://www.w3.org/TR/PNG/#11pHYs\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n  decodeApngImage() {\n    this._apng.width = this._png.width;\n    this._apng.height = this._png.height;\n    this._apng.channels = this._png.channels;\n    this._apng.depth = this._png.depth;\n    this._apng.numberOfFrames = this._numberOfFrames;\n    this._apng.numberOfPlays = this._numberOfPlays;\n    this._apng.text = this._png.text;\n    this._apng.resolution = this._png.resolution;\n    for (let i = 0; i < this._numberOfFrames; i++) {\n      const newFrame = {\n        sequenceNumber: this._frames[i].sequenceNumber,\n        delayNumber: this._frames[i].delayNumber,\n        delayDenominator: this._frames[i].delayDenominator,\n        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)\n      };\n      const frame = this._frames.at(i);\n      if (frame) {\n        frame.data = decodeInterlaceNull({\n          data: frame.data,\n          width: frame.width,\n          height: frame.height,\n          channels: this._apng.channels,\n          depth: this._apng.depth\n        });\n        if (this._hasPalette) {\n          this._apng.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n          this._apng.transparency = this._transparency;\n        }\n        if (i === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {\n          newFrame.data = frame.data;\n        } else {\n          const prevFrame = this._apng.frames.at(i - 1);\n          this.disposeFrame(frame, prevFrame, newFrame);\n          this.addFrameDataToCanvas(newFrame, frame);\n        }\n        this._apng.frames.push(newFrame);\n      }\n    }\n    return this._apng;\n  }\n  disposeFrame(frame, prevFrame, imageFrame) {\n    switch (frame.disposeOp) {\n      case DisposeOpType.NONE:\n        break;\n      case DisposeOpType.BACKGROUND:\n        for (let row = 0; row < this._png.height; row++) {\n          for (let col = 0; col < this._png.width; col++) {\n            const index = (row * frame.width + col) * this._png.channels;\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = 0;\n            }\n          }\n        }\n        break;\n      case DisposeOpType.PREVIOUS:\n        imageFrame.data.set(prevFrame.data);\n        break;\n      default:\n        throw new Error('Unknown disposeOp');\n    }\n  }\n  addFrameDataToCanvas(imageFrame, frame) {\n    const maxValue = 1 << this._png.depth;\n    const calculatePixelIndices = (row, col) => {\n      const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;\n      const frameIndex = (row * frame.width + col) * this._png.channels;\n      return {\n        index,\n        frameIndex\n      };\n    };\n    switch (frame.blendOp) {\n      case BlendOpType.SOURCE:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = frame.data[frameIndex + channel];\n            }\n          }\n        }\n        break;\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n      case BlendOpType.OVER:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];\n              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);\n              imageFrame.data[index + channel] += value;\n            }\n          }\n        }\n        break;\n      default:\n        throw new Error('Unknown blendOp');\n    }\n  }\n  decodeImage() {\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this._png.data = decodeInterlaceNull({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      this._png.data = decodeInterlaceAdam7({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else {\n      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n    }\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n  }\n  pushDataToFrame() {\n    const result = this._inflator.result;\n    const lastFrame = this._frames.at(-1);\n    if (lastFrame) {\n      lastFrame.data = result;\n    } else {\n      this._frames.push({\n        sequenceNumber: 0,\n        width: this._png.width,\n        height: this._png.height,\n        xOffset: 0,\n        yOffset: 0,\n        delayNumber: 0,\n        delayDenominator: 0,\n        disposeOp: DisposeOpType.NONE,\n        blendOp: BlendOpType.SOURCE,\n        data: result\n      });\n    }\n    this._inflator = new Inflator();\n    this._writingDataChunks = false;\n  }\n}\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}","map":{"version":3,"names":["IOBuffer","inflate","Inflate","Inflator","checkCrc","decodeInterlaceAdam7","decodeInterlaceNull","checkSignature","decodetEXt","readKeyword","textChunkName","ColorType","CompressionMethod","DisposeOpType","FilterMethod","InterlaceMethod","BlendOpType","PngDecoder","_checkCrc","_inflator","_png","_apng","_end","_hasPalette","_palette","_hasTransparency","_transparency","_compressionMethod","_filterMethod","_interlaceMethod","_colorType","_isAnimated","_numberOfFrames","_numberOfPlays","_frames","_writingDataChunks","constructor","data","options","width","height","channels","Uint8Array","depth","text","numberOfFrames","numberOfPlays","frames","Uint16Array","UNKNOWN","setBigEndian","decode","length","readUint32","type","readChars","decodeChunk","decodeImage","decodeApng","decodeApngChunk","decodeApngImage","offset","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","decodepHYs","skip","Error","pushDataToFrame","decodeACTL","decodeFCTL","decodeFDAT","image","checkBitDepth","readUint8","colorType","GREYSCALE","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE_ALPHA","TRUECOLOUR_ALPHA","DEFLATE","sequenceNumber","xOffset","yOffset","delayNumber","readUint16","delayDenominator","disposeOp","blendOp","push","RangeError","l","palette","i","dataLength","dataOffset","byteOffset","buffer","err","alpha","readByte","name","compressionMethod","compressedProfile","readBytes","iccEmbeddedProfile","profile","ppuX","ppuY","unitSpecifier","resolution","x","y","unit","newFrame","frame","at","transparency","prevFrame","disposeFrame","addFrameDataToCanvas","imageFrame","NONE","BACKGROUND","row","col","index","channel","PREVIOUS","set","maxValue","calculatePixelIndices","frameIndex","SOURCE","OVER","sourceAlpha","foregroundValue","value","Math","floor","result","ADAPTIVE","NO_INTERLACE","ADAM7","lastFrame"],"sources":["C:/Users/edrin/OneDrive/Desktop/Mobility/SmartMobilitySimulator.UI/node_modules/fast-png/lib-esm/PngDecoder.js"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType, } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n    _checkCrc;\n    _inflator;\n    _png;\n    _apng;\n    _end;\n    _hasPalette;\n    _palette;\n    _hasTransparency;\n    _transparency;\n    _compressionMethod;\n    _filterMethod;\n    _interlaceMethod;\n    _colorType;\n    _isAnimated;\n    _numberOfFrames;\n    _numberOfPlays;\n    _frames;\n    _writingDataChunks;\n    constructor(data, options = {}) {\n        super(data);\n        const { checkCrc = false } = options;\n        this._checkCrc = checkCrc;\n        this._inflator = new Inflator();\n        this._png = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            data: new Uint8Array(0),\n            depth: 1,\n            text: {},\n        };\n        this._apng = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            depth: 1,\n            numberOfFrames: 1,\n            numberOfPlays: 0,\n            text: {},\n            frames: [],\n        };\n        this._end = false;\n        this._hasPalette = false;\n        this._palette = [];\n        this._hasTransparency = false;\n        this._transparency = new Uint16Array(0);\n        this._compressionMethod = CompressionMethod.UNKNOWN;\n        this._filterMethod = FilterMethod.UNKNOWN;\n        this._interlaceMethod = InterlaceMethod.UNKNOWN;\n        this._colorType = ColorType.UNKNOWN;\n        this._isAnimated = false;\n        this._numberOfFrames = 1;\n        this._numberOfPlays = 0;\n        this._frames = [];\n        this._writingDataChunks = false;\n        // PNG is always big endian\n        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n        this.setBigEndian();\n    }\n    decode() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeChunk(length, type);\n        }\n        this.decodeImage();\n        return this._png;\n    }\n    decodeApng() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeApngChunk(length, type);\n        }\n        this.decodeApngImage();\n        return this._apng;\n    }\n    // https://www.w3.org/TR/PNG/#5Chunk-layout\n    decodeChunk(length, type) {\n        const offset = this.offset;\n        switch (type) {\n            // 11.2 Critical chunks\n            case 'IHDR': // 11.2.2 IHDR Image header\n                this.decodeIHDR();\n                break;\n            case 'PLTE': // 11.2.3 PLTE Palette\n                this.decodePLTE(length);\n                break;\n            case 'IDAT': // 11.2.4 IDAT Image data\n                this.decodeIDAT(length);\n                break;\n            case 'IEND': // 11.2.5 IEND Image trailer\n                this._end = true;\n                break;\n            // 11.3 Ancillary chunks\n            case 'tRNS': // 11.3.2.1 tRNS Transparency\n                this.decodetRNS(length);\n                break;\n            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n                this.decodeiCCP(length);\n                break;\n            case textChunkName: // 11.3.4.3 tEXt Textual data\n                decodetEXt(this._png.text, this, length);\n                break;\n            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n                this.decodepHYs();\n                break;\n            default:\n                this.skip(length);\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    decodeApngChunk(length, type) {\n        const offset = this.offset;\n        if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n            this.pushDataToFrame();\n        }\n        switch (type) {\n            case 'acTL':\n                this.decodeACTL();\n                break;\n            case 'fcTL':\n                this.decodeFCTL();\n                break;\n            case 'fdAT':\n                this.decodeFDAT(length);\n                break;\n            default:\n                this.decodeChunk(length, type);\n                this.offset = offset + length;\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    decodeIHDR() {\n        const image = this._png;\n        image.width = this.readUint32();\n        image.height = this.readUint32();\n        image.depth = checkBitDepth(this.readUint8());\n        const colorType = this.readUint8();\n        this._colorType = colorType;\n        let channels;\n        switch (colorType) {\n            case ColorType.GREYSCALE:\n                channels = 1;\n                break;\n            case ColorType.TRUECOLOUR:\n                channels = 3;\n                break;\n            case ColorType.INDEXED_COLOUR:\n                channels = 1;\n                break;\n            case ColorType.GREYSCALE_ALPHA:\n                channels = 2;\n                break;\n            case ColorType.TRUECOLOUR_ALPHA:\n                channels = 4;\n                break;\n            // Kept for exhaustiveness.\n            // eslint-disable-next-line unicorn/no-useless-switch-case\n            case ColorType.UNKNOWN:\n            default:\n                throw new Error(`Unknown color type: ${colorType}`);\n        }\n        this._png.channels = channels;\n        this._compressionMethod = this.readUint8();\n        if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n        }\n        this._filterMethod = this.readUint8();\n        this._interlaceMethod = this.readUint8();\n    }\n    decodeACTL() {\n        this._numberOfFrames = this.readUint32();\n        this._numberOfPlays = this.readUint32();\n        this._isAnimated = true;\n    }\n    decodeFCTL() {\n        const image = {\n            sequenceNumber: this.readUint32(),\n            width: this.readUint32(),\n            height: this.readUint32(),\n            xOffset: this.readUint32(),\n            yOffset: this.readUint32(),\n            delayNumber: this.readUint16(),\n            delayDenominator: this.readUint16(),\n            disposeOp: this.readUint8(),\n            blendOp: this.readUint8(),\n            data: new Uint8Array(0),\n        };\n        this._frames.push(image);\n    }\n    // https://www.w3.org/TR/PNG/#11PLTE\n    decodePLTE(length) {\n        if (length % 3 !== 0) {\n            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n        }\n        const l = length / 3;\n        this._hasPalette = true;\n        const palette = [];\n        this._palette = palette;\n        for (let i = 0; i < l; i++) {\n            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    decodeIDAT(length) {\n        this._writingDataChunks = true;\n        const dataLength = length;\n        const dataOffset = this.offset + this.byteOffset;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    decodeFDAT(length) {\n        this._writingDataChunks = true;\n        let dataLength = length;\n        let dataOffset = this.offset + this.byteOffset;\n        dataOffset += 4;\n        dataLength -= 4;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    // https://www.w3.org/TR/PNG/#11tRNS\n    decodetRNS(length) {\n        switch (this._colorType) {\n            case ColorType.GREYSCALE:\n            case ColorType.TRUECOLOUR: {\n                if (length % 2 !== 0) {\n                    throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n                }\n                if (length / 2 > this._png.width * this._png.height) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n                }\n                this._hasTransparency = true;\n                this._transparency = new Uint16Array(length / 2);\n                for (let i = 0; i < length / 2; i++) {\n                    this._transparency[i] = this.readUint16();\n                }\n                break;\n            }\n            case ColorType.INDEXED_COLOUR: {\n                if (length > this._palette.length) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n                }\n                let i = 0;\n                for (; i < length; i++) {\n                    const alpha = this.readByte();\n                    this._palette[i].push(alpha);\n                }\n                for (; i < this._palette.length; i++) {\n                    this._palette[i].push(255);\n                }\n                break;\n            }\n            // Kept for exhaustiveness.\n            /* eslint-disable unicorn/no-useless-switch-case */\n            case ColorType.UNKNOWN:\n            case ColorType.GREYSCALE_ALPHA:\n            case ColorType.TRUECOLOUR_ALPHA:\n            default: {\n                throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n            }\n            /* eslint-enable unicorn/no-useless-switch-case */\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11iCCP\n    decodeiCCP(length) {\n        const name = readKeyword(this);\n        const compressionMethod = this.readUint8();\n        if (compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n        }\n        const compressedProfile = this.readBytes(length - name.length - 2);\n        this._png.iccEmbeddedProfile = {\n            name,\n            profile: inflate(compressedProfile),\n        };\n    }\n    // https://www.w3.org/TR/PNG/#11pHYs\n    decodepHYs() {\n        const ppuX = this.readUint32();\n        const ppuY = this.readUint32();\n        const unitSpecifier = this.readByte();\n        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\n    }\n    decodeApngImage() {\n        this._apng.width = this._png.width;\n        this._apng.height = this._png.height;\n        this._apng.channels = this._png.channels;\n        this._apng.depth = this._png.depth;\n        this._apng.numberOfFrames = this._numberOfFrames;\n        this._apng.numberOfPlays = this._numberOfPlays;\n        this._apng.text = this._png.text;\n        this._apng.resolution = this._png.resolution;\n        for (let i = 0; i < this._numberOfFrames; i++) {\n            const newFrame = {\n                sequenceNumber: this._frames[i].sequenceNumber,\n                delayNumber: this._frames[i].delayNumber,\n                delayDenominator: this._frames[i].delayDenominator,\n                data: this._apng.depth === 8\n                    ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels)\n                    : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels),\n            };\n            const frame = this._frames.at(i);\n            if (frame) {\n                frame.data = decodeInterlaceNull({\n                    data: frame.data,\n                    width: frame.width,\n                    height: frame.height,\n                    channels: this._apng.channels,\n                    depth: this._apng.depth,\n                });\n                if (this._hasPalette) {\n                    this._apng.palette = this._palette;\n                }\n                if (this._hasTransparency) {\n                    this._apng.transparency = this._transparency;\n                }\n                if (i === 0 ||\n                    (frame.xOffset === 0 &&\n                        frame.yOffset === 0 &&\n                        frame.width === this._png.width &&\n                        frame.height === this._png.height)) {\n                    newFrame.data = frame.data;\n                }\n                else {\n                    const prevFrame = this._apng.frames.at(i - 1);\n                    this.disposeFrame(frame, prevFrame, newFrame);\n                    this.addFrameDataToCanvas(newFrame, frame);\n                }\n                this._apng.frames.push(newFrame);\n            }\n        }\n        return this._apng;\n    }\n    disposeFrame(frame, prevFrame, imageFrame) {\n        switch (frame.disposeOp) {\n            case DisposeOpType.NONE:\n                break;\n            case DisposeOpType.BACKGROUND:\n                for (let row = 0; row < this._png.height; row++) {\n                    for (let col = 0; col < this._png.width; col++) {\n                        const index = (row * frame.width + col) * this._png.channels;\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] = 0;\n                        }\n                    }\n                }\n                break;\n            case DisposeOpType.PREVIOUS:\n                imageFrame.data.set(prevFrame.data);\n                break;\n            default:\n                throw new Error('Unknown disposeOp');\n        }\n    }\n    addFrameDataToCanvas(imageFrame, frame) {\n        const maxValue = 1 << this._png.depth;\n        const calculatePixelIndices = (row, col) => {\n            const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *\n                this._png.channels;\n            const frameIndex = (row * frame.width + col) * this._png.channels;\n            return { index, frameIndex };\n        };\n        switch (frame.blendOp) {\n            case BlendOpType.SOURCE:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] =\n                                frame.data[frameIndex + channel];\n                        }\n                    }\n                }\n                break;\n            // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n            case BlendOpType.OVER:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n                            const foregroundValue = channel % (this._png.channels - 1) === 0\n                                ? 1\n                                : frame.data[frameIndex + channel];\n                            const value = Math.floor(sourceAlpha * foregroundValue +\n                                (1 - sourceAlpha) * imageFrame.data[index + channel]);\n                            imageFrame.data[index + channel] += value;\n                        }\n                    }\n                }\n                break;\n            default:\n                throw new Error('Unknown blendOp');\n        }\n    }\n    decodeImage() {\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        const data = this._isAnimated\n            ? (this._frames?.at(0)).data\n            : this._inflator.result;\n        if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n            throw new Error(`Filter method ${this._filterMethod} not supported`);\n        }\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            this._png.data = decodeInterlaceNull({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            this._png.data = decodeInterlaceAdam7({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else {\n            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n        }\n        if (this._hasPalette) {\n            this._png.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n            this._png.transparency = this._transparency;\n        }\n    }\n    pushDataToFrame() {\n        const result = this._inflator.result;\n        const lastFrame = this._frames.at(-1);\n        if (lastFrame) {\n            lastFrame.data = result;\n        }\n        else {\n            this._frames.push({\n                sequenceNumber: 0,\n                width: this._png.width,\n                height: this._png.height,\n                xOffset: 0,\n                yOffset: 0,\n                delayNumber: 0,\n                delayDenominator: 0,\n                disposeOp: DisposeOpType.NONE,\n                blendOp: BlendOpType.SOURCE,\n                data: result,\n            });\n        }\n        this._inflator = new Inflator();\n        this._writingDataChunks = false;\n    }\n}\nfunction checkBitDepth(value) {\n    if (value !== 1 &&\n        value !== 2 &&\n        value !== 4 &&\n        value !== 8 &&\n        value !== 16) {\n        throw new Error(`invalid bit depth: ${value}`);\n    }\n    return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}